# 스터디 5주차 (p349 ~ p429)
## AOP
IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반 기술의 하나

트랜잭션 경계설정 기능을 성격이 다른 비즈니스 로직 클래스에서 분리

트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있음
-> 시간 절약

단위 테스트
- 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것

통합 테스트
- 두개이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트 하거나 외부 리소스가 참여하는 테스트

여러개으 ㅣ단위가 위존관계 존재 -> 통합테스트 필요

TDD

목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수 있음

Mockito 프레임워크
- 스텁이나 목 오브젝트 작성은 번거롭 -> 프레임워크를 사용하면 편리
- 코드 직관적 


# 스터디 6주차 (p429 ~ p512)
트랜잭션은 비즈니스 로직과는 성격이 다르기 때문에 완전히 분리 가능함

부가기능을 통해 핵심기능을 사용하도록 설계
-> 클라이언트의 요청을 대신 받아주는 -> proxy

실제 오브젝트 -> 타킷 또는 실체

프록시의 특징
- 타깃과 같은 인터페이스를 구현
- 프록시가 타깃을 제어할 수 있는 위치에 있음

프록시 사용 목적
1. 클라이언트가 타깃에 접근하는 방법을 제어
2. 타깃에 부가적인 기능을 부여

## 데코레이터 패턴
타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴

- 여러가지 프록시를 만들어 두고 적절한 순서로 조합해서 사용
- 장점
  - 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용!

대표적인 예
- InputStream
  - 타깃: FileInputStream
  - 데코레이터: BufferedInputStream
- OutputStream

## 프록시 패턴
클라이언트가 타깃에 접근하는 방식을 변경
- 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공

자신이 만들거나 접근할 타깃 클래스 정보를 알고있음

### 리플렉션
프록시를 손쉽게 만들 수 있도록 지원
- java.lang.reflect 패키지

다이나믹 프록시는 리플렉션 기능을 이용해 프록시를 생성

리플렉션
- 자바의 코드 자체를 추상화하여 접근하도록 만든 것

java.lang.reflect.Method
- 메소드의 자세한 정보를 담고있으며 특정 오브젝트의 메소드를 실행시킬 수 있음
- ```java
    Method lengthMethod = String.class.getMethod("length");
  ```

## 다이나믹 프록시
_번거로운 프록시 클래스 작성은 JDK의 다이나믹 프록시를 사용하여 간단하게 만들 수 있음_

프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 오브젝트
- UppercaseHadler

다이나믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 등록하기 번거로움
-> 팩토리 빈으로 만들어야 함
- 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공


### 프록시 팩토리 빈 방식 장점
- 프록시 팩토리 빈의 재사용
- 다이나믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움 제거 가능

-> 프록시를 사용하려면 DI가 필요하고 -> 효율적인 프록시 생성을 위해 다이나믹 프록시를 사용할 때도 팩토리 빈을 통한 DI는 필수!!

### 프록시 팩토리 빈 방식 한계
- 프록시 팩토리 빈의 설정이 반복되는 문제 -> 자동 프록시 생성기와 포인트컷 활용 가능

## ProxyFactoryBean
프록시를 생성하여 빈 오브젝트로 등록하게 해주는 팩토리 빈

어드바이스
- 타깃이 필요 없는 순수한 부가기능
- _**타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트**_
- 자동 검출기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아냄 -> 알아낸 인터페이스를 모두 구현하는 프록시를 만들어줌

포인트컷
- 부가기능 적용 대상 메소드 선정 방법
- 메소드 선정 알고리즘을 담은 오브젝트

어드바이스, 포인트컷 모두 DI를 통해 주입받음 -> OCP원칙

어드바이저
- 어드바이스와 포인트컷을 묶은 오브젝트

## 스프링 AOP
자동 프록시 생성
- 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 생성
  - DefaultAdvisorAutoProxyCreator

포인트컷
- 메소드 뿐만 아니라 클래스도 선정할 수 있는 알고리즘을 모두 갖고있는 포인트컷이 필요 -> 클래스 필터

포인트컷 표현식
- 정규식이나 등의 일종의 표현식 언어를 사용해 포인트컷을 작성할 수 있도록 하는 방법
- AspectJExpressionPointcut 클래스 사용
- AspectJ 포인트컷 표현식
```java
execution([접근제한자패턴] 타입패턴 [타입패턴.] 이름패턴 (타입패턴| "..", ...))
```

### 그래서 AOP란 무엇인가?
- 트랜잭션 서비스 추상화
  - 비즈니스 로직 코드에 영향을 주지 않고 독립적으로 변경이 가능
- 프록시와 데코레이터 패턴
  - 성격이 다른 코드로부터 자유로워짐, 독립적으로 로직을 검증하는 단위테스트 구현 가능
- 다이나믹 프록시와 프록시 팩토리 빈
  - DI 도입, 어드바이스와 포인트컷에서 분리 및 공유 가능
- 자동 프록시 생성 방법과 포인트 컷
  - 포인트컷으로 적용 대상을 손쉽게 선택 가능
- 부가기능의 모듈화
  - 어디바이저
- AOP: 애스팩트 지향 프로그래밍
  - 애스팩트
    - 어드바이저는 단순한 형태의 애스팩트로 볼 수 있음
    - AOP는 OOP를 돕는 보조적인 기능
      - OOP만으로는 모듈화하기 어려운 부가기능을 효과적으로 모듈화하도록 도와주는 기술
    - 애플리케이션을 특정한 관점을 기준으로 바라볼수 있게 해준다는 의미에서 관점지향 프로그래밍이라고도 부름

### AOP 적용 기술
타깃
- 타깃은 부가기능을 부여할 대상
- 핵심기능을 담은 클래스이거나 다른 부가기능을 제공하는 오브젝트

어드바이스
- 타깃에게 제공할 부가기능을 담은 모듈
- 오브젝트로 정의하기도 하지만, 메소드 레벨에서 정의할 수 도 있음
- 메소드 호출과정에 전반적으로 참여하거나, 매소드 호출 과정의 일부에서만 동작

조인포인트
- 어드바이스가 적용될 수 있는 위치
- 메소드의 실행 단계에서만 적용 가능

포인트컷
- 어드바이스를 적용할 조인포인트를 선별하는 작업

프록시
- 클라이언트와 타깃 사이에 투명하게 존재하며 부가기능을 제공하는 오브젝트
- DI를 통해 타깃 대신 클라이언트에게 주입, 
- 스프링은 프록시를 이용해 AOP를 지원

어드바이저
- 어드바이스 + 포인트컷
- 자동프록시 생성기가 어드바이저를 AOP 작업의 정보로 활용

애스펙트
- AOP의 기본 모듈
- 스프링의 어드바이저


### AOP 네임스페이스
스프링의 프록시 방식 AOP를 적용하려면 네가지 빈 등록 필요
- 자동 프록시 생성기
- 어드바이스
- 포인트컷
- 어드바이저

AOP 네임스페이스 , 어드바이저 내장 포인트컷

___"결국 AOP는 트랜잭션 코드를 부가기능 형태로 제공하는 일~~"___

# 스터디 6주차 (p512 ~ p596)
## 트랜잭션 속성
### 트랜잭션 전파
이미 진행중인 트랜잭션에 어떻게 영향을 미칠 수 있는가를 정의

PROPAGATION_REQUIRED
- 진행중인 트랜잭션이 없으면 새로 시작하고 이미 시작된 트랜잭션이 있으면 이에 참여

PROPAGATION_REQUIRES_NEW
- 항상 새로운 트랜잭션을 시작

PROPAGATION_NOT_SUPPORTED
- 트랜잭션 없이 동작

getTransaction()으러 트랜잭션을 어떻게 가져올 지 결정

### 격리수준
격리수준을 조정하여 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 제어 필요
- ISOLATION_DEFAULT

### 제한시간
트랜잭션을 수행하는 제한시간 설정
- 트랜잭션을 직접 시작할수있는 설정과 함께 사용해야 의미 있음

### 읽기전용 

### 트랜잭션 인터셉터
메소드 이름 패턴에 따라 트랜잭션 적용되도록 정의

- 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다
- 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다
- 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 대는 적용되지 않는다

### 트랜잭션 속성 적용
- 트랜잭션 경계설정의 부가기능 일원화
  - 서비스 계층에 설정했다면, 서비스를 거쳐 DAO에 접근하도록 설계
- 서비스 빈에 적용되는 포인트컷 표현식 등록
  - *Service로 끝나는 모든 빈에 적용
- 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록

## 트랜잭션 애노테이션
직접 타깃에 트랜잭션 속성정보를 가진 애노테이션을 지정!
- 설정파일에서 패턴으로 분류 가능한 그룹을 만들어 일괄적으로 속성을 부여하는 대신,

### @Transactional
1. 타깃의 메소드에 적용되어 있는지 확인
   - 부여되어 있다면 이를 속성으로 사용
2. 대체 후보인 타깃 클래스에 부여된 애노테이션 확인
   - 이를 메소드의 트랜잭션으로 사용

## 트랜잭션 전파 속성
REQUIRED
- 진행중인 트랜잭션이 있으면 참여, 아니면 새로운 트랜잭션 시작

선언적 트랜잭션
- AOP를 이용해 코드 외부에서 트랜잭션 기능을 부여해주고 속성을 지정할 수 있게 하는 방법

프로그램에 의한 트랜잭션
- 트랜잭션 API를 이용해 직접 코드안에서 사용하는 방법

## 트랜잭션 추상화
트랜잭션 동기화

### @Rollback
- 테스트용 @Transactional은 테스트가 끝나면 자동으로 롤백시킴
- 자동 롤백을 막기 위해 @Rollback 애노테이션 사용
  - @Rollback(false)
  

@NotTransactional, @Transactional(propagation=Propagation.NEVER)




