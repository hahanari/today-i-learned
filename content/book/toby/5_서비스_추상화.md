# 스터디 4주차 (p259 ~ p348)
## 서비스 추상화
- 실수를 유발하지 않게 하기위해 Enum을 사용
  - 대신, DB에 넣을 때는 변환하여 넣기
    - MyBatis나 JPA 경우에는 알아서 스트링으로 변환하지만 사용 권장 안함
- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 분리
  - 내부적으로 책임과 역할에 따라 메소드로 분리
- 인터페이스와 DI를 활용하여 결합도를 낮추자


# 스터디 5주차 (p349 ~ p429)
## 트랜잭션 서비스 추상화
테스트용 확장 클래스 생성
- 일부 메소드 오버라이딩

___"DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요"___

트랜잭션 롤백
- 문제가 발생 시 앞에서 처리한 작업도 취소시킨다

트랜잭션 커밋
- 모든 작업이 완료되면 DB에 알려줘 작업을 확정시킨다

트랜잭션 경계 설정
- setAutoCommit(false), commit(), rollback() 시작선언 및 종료 작업

로컬 트랜잭션
- 하나의 DB 커넥션 안에서 만들어지는 트랜잭션

템플릿메소드가 호출될 때 마다 트랜잭션이 새로 만들어지고 종료된다

-> Connection 정보를 파라미터로 전달 -> 비효율적
-> 트랜잭션 동기화 방식을 활용하는 것이 편리

## 트랜잭션 동기화
- 파라미터를 통해 일일히 Connection 오브젝트를 전달할 일이 없어짐
- 멀티스레드 환경
  - TransactionSynchronizationManager

글로벌 트랜잭션
- 여러게의 DB 연결
- Java Transaction API 사용

자바에서 사용되는 트랜잭션 API의 종류와 방법 다양 -> 환경과 서버에 따라 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경되어야 함
-> 단일 책임 원칙에 위배, 특정 기술에 대한 강한 결합 생성 

-> 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하기 위해 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 됨!

## 스프링의 트랜잭션 서비스 추상화
- 로우레벨의 트랜잭션 기술과 API 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입
-> 애플리케이션에서 직접 각 기술의 트랜잭션 API를 이용하지 않고도 일관된 방식으로 트랜잭션을 제어하는 트랜잭션 경계설정 작업이 가능

JavaMail같은 확장 및 테스트가 어려운 기술도 추상화를 통해 편리하게 테스트 작성 가능하다

## 의존 오브젝트 변경을 통한 테스트 방법

테스트 대역
- 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트
- 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공함
- 테스트 환경을 만들어 주기 위해 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게 자주 테스트를 실행할 수 있도록 사용하는 오브젝트

스텁 -> 상태 검증 
  - 테스트가 수행될 수 있도록 의존 오브젝트에 간접적으로 입력 값을 제공

목 오브젝트 -> 행위 검증
  - 스텁 기능 + 출력값(기대값)까지 확인이 가능









